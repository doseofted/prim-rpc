{/* SECTION: setup */}

import { LayoutDocs } from "../../components/LayoutDocs"
export const meta = {
	title: "Getting Started",
}
export default ({ children }) => <LayoutDocs meta={meta}>{children}</LayoutDocs>

{/* !SECTION setup */}

# {meta.title}

## What is it?

Prim+RPC is a bridge between JavaScript environments, without the extra boilerplate code. The primary use case of this
library is making plain function calls to a server from some client (RPC), as if that code had been written on the
client itself. The goal is to write plain JavaScript, or TypeScript if you prefer, and immediately invoke typed code
without verbose wrappers around the communication channel.

Let's say, as a contrived example, that you have the following function defined on a server (remembering that TypeScript
is optional):

```ts my-form-validation.ts
// NOTE: this file runs on a server
interface SomeForm {
	name?: string
}
/** Determine if name of visitor is Ted. It's probably not. */
export function validateSomeForm(form: SomeForm = {}) {
	if (form.name === "Ted") {
		return "Hi Ted!"
	} else {
		return "You're not Ted!"
	}
}
validateSomeForm.rpc = true
```

Notice that we added a property to our function (`validateSomeForm.rpc`). This is a safety feature to explicitly tell
Prim+RPC that we want to share this function. Since functions are technically objects in JavaScript, this code is
perfectly valid.

Now we want to expose `validateSomeForm` to the browser where a user may submit some form. This is simple with the
Prim+RPC server:

```ts index.ts focus=1:3,9:12
// NOTE: this file runs on a server
import { validateSomeForm } from "./my-form-validation.ts"
import { createPrimServer } from "@doseofted/prim-rpc"
import Fastify from "fastify"
import { primMethodFastify } from "@doseofted/prim-plugins/fastify"

const fastify = Fastify()

createPrimServer({
	module: { validateSomeForm },
	methodHandler: primMethodFastify({ fastify }),
})

await fastify.listen({ host, port: 3001 })
```

Importantly, Prim+RPC does not dictate or have a preference regarding how you send RPC. This means that Prim+RPC can be
used to bridge any two kinds of JavaScript environments where communication is otherwise difficult. This could mean
communication between two physically separated servers, between a server and client, between two separate
processes/threads. Prim+RPC can connect all of these environments, with type definitions attached, and without the need
for a separate schema/definition language.

In this example, we

Prim+RPC is written in TypeScript and allows you to take advantage of type definitions in your code from one environment
to another without manually copying or recreating definitions, whether those are written in TypeScript or JavaScript
with JSDoc comments. There's also no client generation script or other transpilation step needed to access type
definitions since any types you've already written inside of your code are utilized by Prim+RPC.

In addition to the library itself, Prim+RPC also includes a low-level documentation generator, based on TypeDoc, that
you can use to generate your own custom documentation website for your RPC (both JavaScript and TypeScript). You can
even generate code snippets for usage of Prim+RPC in other languages using the HTTPsnippet library. On the topic of
other environments, the RPC created with Prim+RPC is purposefully very simple and easy to structure, in the event that
you need to use code outside of JavaScript. In the future, this documentation may also be used to generate a JSON schema
for your RPC so that other languages can have typed requests by making their requests with JSON.

Prim+RPC is created with the goal of allowing you to write the code that you actually want to write with the tools that
you already enjoy using. While other tools require separate type/schema definitions, Prim+RPC takes advantage of
existing types in your JavaScript/TypeScript. While other tools require generation of a client-side code to communicate
with a server, Prim+RPC utilizes JavaScript Proxies to automatically generate the correct RPC code based on your
function calls. While other tools generally assume usage over HTTP, Prim+RPC utilizes separate plugins to communicate
over any channel that you'd like (with default plugins, of course).

While file uploads, serialization of data, batching of requests, and server-sent data are considered separate features
to be implemented in other tools, Prim+RPC supports these out of the box either directly or by utilizing a third party
tool, with minimal setup on the developer's side.

In short, Prim+RPC allows you to focus less on message transport and more on the message being sent.

## How Does It Work?

There are two parts of Prim+RPC for communicating between two different environments, typically a server and a
browser/client.

The server is responsible for making your code available to the client. You can write any plain JavaScript function that
you'd like, pass it to Prim+RPC, and it becomes available for the client to use once flag as publicly available (nothing
is shared by default). The server reads given RPC (a simple JSON object typically transported over HTTP or WebSocket)
and translates this into the proper function call on the server.

The client is responsible for structuring requests into RPC that the server can understand. When you make a function
call using the client, that function call is translated into RPC using a recursive JavaScript Proxy. The Proxy object is
JavaScript's answer to meta-programming and allows tools like Prim+RPC to inspect usage of properties and methods on an
object. This means that Prim+RPC doesn't need to generate a client to communicate with the server. Instead, it uses the
language itself.

There are many other more intricate details concerning how Prim+RPC works: batching requests, handling files,
interaction with plugins, just to name a few. These are topics that may be covered in-depth as this documentation
progresses.

## Show Me An Example

<CH.Code>

```js server.js
// on server:
export function sayHello(x, y) {
	return `${x}, meet ${y}.`
}
```

---

```js client.js
// in browser:
const greeting = await sayHello("Backend", "Frontend")
// greeting === "Backend, meet Frontend."
```

</CH.Code>

Natoque penatibus et magnis dis. Quisque id diam vel quam. Sagittis eu volutpat odio facilisis mauris sit amet massa.
Sed ullamcorper morbi tincidunt ornare massa eget egestas purus. Elementum facilisis leo vel fringilla est. A
condimentum vitae sapien pellentesque. Et netus et malesuada fames ac turpis egestas. Diam vel quam elementum pulvinar
etiam non quam. Vitae et leo duis ut. Aliquam purus sit amet luctus venenatis lectus magna fringilla. Ut ornare lectus
sit amet est placerat in egestas. Sed egestas egestas fringilla phasellus faucibus. Erat velit scelerisque in dictum non
consectetur a erat. Ultricies leo integer malesuada nunc vel. Amet justo donec enim diam. Augue lacus viverra vitae
congue. Nisi est sit amet facilisis magna etiam tempor. Senectus et netus et malesuada fames ac turpis. In fermentum et
sollicitudin ac orci. Odio euismod lacinia at quis.

Sem integer vitae justo eget magna. Donec ultrices tincidunt arcu non. Vulputate dignissim suspendisse in est. Imperdiet
sed euismod nisi porta. Egestas purus viverra accumsan in nisl nisi. Neque convallis a cras semper auctor neque vitae
tempus. Sagittis aliquam malesuada bibendum arcu vitae elementum curabitur. Rhoncus aenean vel elit scelerisque mauris
pellentesque pulvinar. Iaculis nunc sed augue lacus viverra vitae congue eu. Consequat interdum varius sit amet mattis
vulputate enim. Tellus integer feugiat scelerisque varius morbi enim nunc faucibus. Dignissim sodales ut eu sem. Gravida
in fermentum et sollicitudin ac orci. Risus commodo viverra maecenas accumsan lacus vel facilisis volutpat est.

Ut morbi tincidunt augue interdum velit. Ultrices in iaculis nunc sed augue lacus viverra. Quam id leo in vitae turpis
massa sed. Rhoncus est pellentesque elit ullamcorper dignissim. Sagittis eu volutpat odio facilisis mauris sit. Molestie
at elementum eu facilisis sed odio morbi quis commodo. Viverra nibh cras pulvinar mattis nunc sed blandit. Duis at
tellus at urna condimentum mattis. Facilisis magna etiam tempor orci eu lobortis elementum nibh. Adipiscing elit duis
tristique sollicitudin nibh sit amet. Proin sed libero enim sed faucibus turpis. Sed cras ornare arcu dui vivamus arcu
felis bibendum ut.

Consectetur lorem donec massa sapien faucibus et molestie. Quis ipsum suspendisse ultrices gravida dictum fusce ut
placerat orci. Commodo elit at imperdiet dui accumsan sit amet nulla facilisi. Quis eleifend quam adipiscing vitae proin
sagittis nisl. Pellentesque id nibh tortor id aliquet lectus proin. Vel eros donec ac odio tempor. Elementum tempus
egestas sed sed risus pretium quam. Diam volutpat commodo sed egestas egestas fringilla phasellus faucibus scelerisque.
Libero justo laoreet sit amet cursus sit amet. Neque vitae tempus quam pellentesque nec nam aliquam. Tristique magna sit
amet purus gravida quis blandit. Arcu bibendum at varius vel pharetra vel turpis nunc eget. Faucibus turpis in eu mi
bibendum neque egestas congue quisque. Sapien et ligula ullamcorper malesuada proin libero nunc consequat interdum.
Convallis convallis tellus id interdum velit laoreet id. Magna fringilla urna porttitor rhoncus dolor purus non enim
praesent.
