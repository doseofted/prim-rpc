{/* SECTION: setup */}

import { LayoutDocs } from "../../components/LayoutDocs"
export const meta = {
	title: "Getting Started",
}
export default ({ children }) => <LayoutDocs meta={meta}>{children}</LayoutDocs>

{/* !SECTION setup */}

# {meta.title}

## What is it?

Prim+RPC is a bridge between JavaScript environments, without the extra boilerplate code. The primary use case of this
library is making plain function calls to a server from some client (RPC), as if that code had been written on the
client itself. The goal is to write plain JavaScript, or TypeScript if you prefer, and immediately invoke typed code
without verbose wrappers around the communication channel.

Importantly, Prim+RPC does not dictate or have a preference regarding how you send RPC through its modular design. This
means that Prim+RPC can be used to bridge any two kinds of JavaScript environments where communication is otherwise
difficult. This could mean communication between two physically separated servers, between a server and client, between
two separate processes, between two threads, or between a primary and background service. Prim+RPC can connect all of
these environments, with type definitions attached, and without the need for a separate definition/data language.

Prim+RPC is written in TypeScript and allows you to take advantage of type definitions in your code from one environment
to another without manually copying or recreating definitions, whether those are written in TypeScript or JavaScript
with JSDoc comments. There's also no client generation script or other transpilation step needed to access type
defintions since any types you've already written inside of your code are utilized by Prim+RPC. Through the usage of a
custom JSON parser like superjson you can even use types like Dates and Regex directly with Prim+RPC without the need
for manually serializing data before sending it.

In addition to the library itself, Prim+RPC also includes a low-level documentation generator, based on TypeDoc, that
you can use to generate your own custom documentation website for your RPC. You can even generate code snippets for
usage of Prim+RPC in other languages using the HTTPsnippet library. On the topic of other environments, the RPC created
with Prim+RPC is purposefully very simple and easy to structure, in the event that you need to use code outside of
JavaScript.

Prim+RPC is created with the goal of allowing you to write the code that you actually want to write with the tools that
you already enjoy using. While other tools require separate type/schema definitions, Prim+RPC takes advantage of
existing types in your JavaScript/TypeScript. While other tools require generation of a client-side code to communicate
with a server, Prim+RPC utilizies JavaScript Proxies to automatically generate the correct RPC code based on your
function calls. While other tools generally assume usage over HTTP, Prim+RPC utilizes separate plugins to communicate
over any channel that you'd like (with default plugins, of course).

There are also many additional features of Prim+RPC that stand out from other tools. For instance, there is file upload
support with Prim+RPC through the usage of plugins. Another example: callbacks on the server can be used from the client
without the need for manually opening a WebSocket or configuring "subscriptions" as commonly used in other tools.

Prim+RPC allows you to focus less on how you send something and more on the message itself that needs to be sent.

## How Does It Work?

Prim+RPC is fairly simple in how it works. There are two parts of Prim+RPC for communicating between two different
environments (typically a server and a browser).

The server is responsible for making your code available to the client. You can write any function that you'd like (just
a plain JavaScript function), flag it as publicy available, pass it to Prim+RPC, and it's now available for the client
to use. The server reads RPC (a JSON object) and translates this into the proper function call available on the server.

The client is responsible for structuring requests into RPC that the server can understand. When you make a function
call using the client, that function call is translated into RPC using a recursive JavaScript Proxy. The Proxy object is
JavaScript's answer to metaprogramming and allow tools like Prim+RPC to inspect usage of certain properties and methods
on an object. This means that Prim+RPC doesn't need to generate a client to communicate with the server. Instead, it
uses the language itself.

There are many other more intricate details concerning how Prim+RPC works such as the process for handling files and for
handling callbacks and generating documentation however these are topics that may be covered in-depth as this
documentation progresses.

## Example

<CH.Code>

```js server.js
// on server:
export function sayHello(x, y) {
	return `${x}, meet ${y}.`
}
```

---

```js client.js
// in browser:
const greeting = await sayHello("Backend", "Frontend")
// greeting === "Backend, meet Frontend."
```

</CH.Code>

Natoque penatibus et magnis dis. Quisque id diam vel quam. Sagittis eu volutpat odio facilisis mauris sit amet massa.
Sed ullamcorper morbi tincidunt ornare massa eget egestas purus. Elementum facilisis leo vel fringilla est. A
condimentum vitae sapien pellentesque. Et netus et malesuada fames ac turpis egestas. Diam vel quam elementum pulvinar
etiam non quam. Vitae et leo duis ut. Aliquam purus sit amet luctus venenatis lectus magna fringilla. Ut ornare lectus
sit amet est placerat in egestas. Sed egestas egestas fringilla phasellus faucibus. Erat velit scelerisque in dictum non
consectetur a erat. Ultricies leo integer malesuada nunc vel. Amet justo donec enim diam. Augue lacus viverra vitae
congue. Nisi est sit amet facilisis magna etiam tempor. Senectus et netus et malesuada fames ac turpis. In fermentum et
sollicitudin ac orci. Odio euismod lacinia at quis.

Sem integer vitae justo eget magna. Donec ultrices tincidunt arcu non. Vulputate dignissim suspendisse in est. Imperdiet
sed euismod nisi porta. Egestas purus viverra accumsan in nisl nisi. Neque convallis a cras semper auctor neque vitae
tempus. Sagittis aliquam malesuada bibendum arcu vitae elementum curabitur. Rhoncus aenean vel elit scelerisque mauris
pellentesque pulvinar. Iaculis nunc sed augue lacus viverra vitae congue eu. Consequat interdum varius sit amet mattis
vulputate enim. Tellus integer feugiat scelerisque varius morbi enim nunc faucibus. Dignissim sodales ut eu sem. Gravida
in fermentum et sollicitudin ac orci. Risus commodo viverra maecenas accumsan lacus vel facilisis volutpat est.

Ut morbi tincidunt augue interdum velit. Ultrices in iaculis nunc sed augue lacus viverra. Quam id leo in vitae turpis
massa sed. Rhoncus est pellentesque elit ullamcorper dignissim. Sagittis eu volutpat odio facilisis mauris sit. Molestie
at elementum eu facilisis sed odio morbi quis commodo. Viverra nibh cras pulvinar mattis nunc sed blandit. Duis at
tellus at urna condimentum mattis. Facilisis magna etiam tempor orci eu lobortis elementum nibh. Adipiscing elit duis
tristique sollicitudin nibh sit amet. Proin sed libero enim sed faucibus turpis. Sed cras ornare arcu dui vivamus arcu
felis bibendum ut.

Consectetur lorem donec massa sapien faucibus et molestie. Quis ipsum suspendisse ultrices gravida dictum fusce ut
placerat orci. Commodo elit at imperdiet dui accumsan sit amet nulla facilisi. Quis eleifend quam adipiscing vitae proin
sagittis nisl. Pellentesque id nibh tortor id aliquet lectus proin. Vel eros donec ac odio tempor. Elementum tempus
egestas sed sed risus pretium quam. Diam volutpat commodo sed egestas egestas fringilla phasellus faucibus scelerisque.
Libero justo laoreet sit amet cursus sit amet. Neque vitae tempus quam pellentesque nec nam aliquam. Tristique magna sit
amet purus gravida quis blandit. Arcu bibendum at varius vel pharetra vel turpis nunc eget. Faucibus turpis in eu mi
bibendum neque egestas congue quisque. Sapien et ligula ullamcorper malesuada proin libero nunc consequat interdum.
Convallis convallis tellus id interdum velit laoreet id. Magna fringilla urna porttitor rhoncus dolor purus non enim
praesent.
