{/* SECTION: setup */}

import { LayoutDocs } from "@/components/LayoutDocs"
import { Alert } from "@/components/Alert"
export const meta = {
	title: "Introduction",
}
export default ({ children }) => <LayoutDocs meta={meta}>{children}</LayoutDocs>

{/* !SECTION setup */}

# {meta.title}

<Alert prose icon="carbon:information">

**TLDR:** Prim+RPC is a framework for calling ordinary JavaScript functions over any transport, with support for typed
requests, batching, file uploads, advanced serialization, and more.

Use Prim+RPC to communicate between different JavaScript environments where functions can't be called directly, such as
client and server. Prim+RPC allows you to focus less on message transport and more on the message being sent.

Ready to get [get started](/docs/setup)?

</Alert>

## Table of Contents

## What is it?

Prim+RPC is a bridge between JavaScript environments, without the extra boilerplate code. The primary use case of this
library is making plain function calls to a server from some client (RPC), as if that code had been written on the
client itself. The goal is to write plain JavaScript, or TypeScript if you prefer, and immediately invoke typed code
without verbose wrappers around the communication channel.

<CH.Code>

```ts server.ts focus=3:6
// import the Prim+RPC server
import { createPrimServer } from "@doseofted/prim-rpc"
// create any ordinary function
export function sayHello(x, y) {
	return `${x}, meet ${y}.`
}
// signal that this function is intended to be called as RPC
sayHello.rpc = true
// pass your function to Prim+RPC server
const prim = createPrimServer({
	module: { sayHello },
	// ... setup transport options (described in documentation)
})
// now make RPC from the client
```

---

```ts client.ts focus=10:11
// import Prim+RPC client
import { createPrimClient } from "@doseofted/prim-rpc"
// import types from server
import type * as module from "./server.ts"
// configure client with types and endpoint used on the server
const { sayHello } = createPrimClient<typeof module>({
	endpoint: "http://localhost:1234/prim",
	// ... setup transport options (described in documentation)
})
// call function as if it exists on the client (which it doesn't)
const greeting = await sayHello("Backend", "Frontend")
// greeting === "Backend, meet Frontend."
```

</CH.Code>

Importantly, Prim+RPC does not dictate or have a preference regarding how you send or receive RPC. This means that
Prim+RPC can be used to bridge any two kinds of JavaScript environments where communication is otherwise difficult. This
could mean communication between two physically separated servers, between a server and client, or between two separate
processes/threads. Prim+RPC can connect all of these environments, with type definitions attached, and without the need
for a separate schema/definition language.

Prim+RPC is written in TypeScript and allows you to take advantage of type definitions in your code from one environment
to another without manually copying or recreating definitions, whether those are written in TypeScript or JavaScript
with JSDoc comments. There's also no client generation script or other transpilation step needed to access type
definitions since any types you've already written inside of your code are utilized by Prim+RPC.

In addition to the library itself, Prim+RPC also includes a low-level documentation generator, based on TypeDoc, that
you can use to generate your own custom documentation website for your RPC (both JavaScript and TypeScript). You can
even generate code snippets for usage of Prim+RPC in other languages using the HTTPsnippet library. On the topic of
other environments, the RPC created with Prim+RPC is purposefully very simple and easy to structure, in the event that
you need to use code outside of JavaScript. In the future, this documentation may also be used to generate a JSON schema
for your RPC so that other languages can have typed requests by making their requests with JSON.

Prim+RPC is created with the goal of allowing you to write the code that you actually want to write with the tools that
you already enjoy using. While other tools require separate type/schema definitions, Prim+RPC takes advantage of
existing types in your JavaScript/TypeScript. While other tools require generation of a client-side code to communicate
with a server, Prim+RPC utilizes JavaScript Proxies to automatically generate the correct RPC code based on your
function calls. While other tools generally assume usage over HTTP, Prim+RPC utilizes separate plugins to communicate
over any channel that you'd like (with default plugins, of course).

While file uploads, serialization of data, batching of requests, and server-sent data are considered separate features
to be implemented in other tools, Prim+RPC supports these out of the box either directly or by utilizing a third party
tool, with minimal setup on the developer's side.

In short, Prim+RPC allows you to focus less on message transport and more on the message being sent.

## A Demonstration

<Alert prose icon="carbon:information">

The following is a demonstration; not a tutorial. If you'd like to follow along, please follow
[Setup Instructions](/docs/setup).

</Alert>

Prim+RPC allows you to write a plain JavaScript function in one environment (like a server) and share it directly with
another environment (like a browser). The best way to introduce Prim+RPC is with an example. Let's take the example from
the homepage:

```ts server.ts
// on server:
export function sayHello(x, y) {
	return `${x}, meet ${y}.`
}
```

This is a regular JavaScript function. If we want to expose this from the server to the outside world, we can create a
Prim+RPC server to share it:

```ts server.ts mark=2,7,9:12
// on server:
import { createPrimServer } from "@doseofted/prim-rpc"

export function sayHello(x, y) {
	return `${x}, meet ${y}.`
}
sayHello.rpc = true

const prim = createPrimServer({
	module: { sayHello },
	// ... other options
})
```

In this example, we've created a Prim+RPC server instance and gave it our function to use. We also added boolean
property named `rpc` to our function to specify that this function is allowed to be used as an RPC.

We can now make an RPC directly to the Prim+RPC server:

```ts server.ts focus=14:19
// on server:
import { createPrimServer } from "@doseofted/prim-rpc"

export function sayHello(x, y) {
	return `${x}, meet ${y}.`
}
sayHello.rpc = true

const prim = createPrimServer({
	module: { sayHello },
	// ... other options
})

// below is the equivalent of calling `sayHello("Backend", "Frontend")`
const { result: greeting } = await prim.server().prepareRpc({
	method: "sayHello",
	params: ["Backend", "Frontend"],
})
// greeting === "Backend, meet Frontend."
```

Of course, on the server we can just call the function directly. Where Prim+RPC becomes useful is when you combine this
with the Prim+RPC client which automatically generates this RPC. First, we'll make this RPC available with an HTTP
server. Prim+RPC doesn't concern itself with the method of delivery and instead allows you to use plugins to send RPC.
In this example, we'll use a plugin for a server framework called Fastify but there are many other plugins available and
it is easy to write your own.

```ts server.ts mark=3,4,6,15,19
// on server:
import { createPrimServer } from "@doseofted/prim-rpc"
import { primMethodFastify } from "@doseofted/prim-plugins/fastify"
import Fastify from "fastify"

const fastify = Fastify()

export function sayHello(x, y) {
	return `${x}, meet ${y}.`
}
sayHello.rpc = true

const prim = createPrimServer({
	module: { sayHello },
	methodHandler: primMethodFastify({ fastify }),
	// ... other options
})

await fastify.listen({ port: 1234 })
```

Now our function is available over the network at `http://localhost:1234/prim` (default path name can be changed if
needed). We can even test this out before configuring our client, by making a request over the terminal:

```zsh
curl --request POST \
  --url http://localhost:1234/prim \
  --header 'Content-Type: application/json' \
  --data '{
	"method": "sayHello",
	"params": ["Frontend", "Backend"]
}'
```

In a new file, we'll create a Prim+RPC client that will communicate with our newly configured server.

```ts client.ts mark=3,6
// on client:
import { createPrimClient } from "@doseofted/prim-rpc"
import type * as module from "./server.ts"

const prim = createPrimClient<typeof module>({
	endpoint: "http://localhost:1234/prim",
})
```

Note that we imported the types directly from our server using TypeScript and passed it to the Prim+RPC client. In
JavaScript, we could've also used a JSDoc comment to annotate our client. Also note that we are _only_ importing types:
code from the server is not imported. Instead, this will be requested over the endpoint that we've configured.

By default, the Prim+RPC does not assume a default client. Similar to the server, we provide this functionality through
the use of plugins. Let's add support for our server using the browser's built-in fetch client:

```ts client.ts mark=3,8
// on client:
import { createPrimClient } from "@doseofted/prim-rpc"
import { createFetchClient } from "@doseofted/prim-plugins/browser-api"
import type * as module from "./server.ts"

const prim = createPrimClient<typeof module>({
	endpoint: "http://localhost:1234/prim",
	client: createFetchClient(),
})
```

We also have the option of configuring our own client if we'd like (it doesn't even need to be an HTTP client). Now
we're ready to call our function from the client to our server!

```ts client.ts focus=11:12
// on client:
import { createPrimClient } from "@doseofted/prim-rpc"
import { createFetchClient } from "@doseofted/prim-plugins/browser-api"
import type * as module from "./server.ts"

const prim = createPrimClient<typeof module>({
	endpoint: "http://localhost:1234/prim",
	client: createFetchClient(),
})

const greeting = await prim.sayHello("Backend", "Frontend")
// greeting === "Backend, meet Frontend."
```

We can now create more JavaScript/TypeScript functions and easily share them with the client!

This basic example demonstrates how to make a simple function call but Prim+RPC has much more functionality built in. In
this documentation you'll learn how to support file uploads, use callbacks, batch requests, generate documentation,
support automatic serialization of objects like Dates, and much more, all with Prim+RPC.

## How Does This Work?

<Alert icon="carbon:warning" type="alert-warning">
	Work in Progress
</Alert>

There are two parts of Prim+RPC for communicating between two different environments, typically a server and a
browser/client.

The server is responsible for making your code available to the client. You can write any plain JavaScript function that
you'd like, pass it to Prim+RPC, and it becomes available for the client to use once flag as publicly available (nothing
is shared by default). The server reads given RPC, a simple JSON object typically transported over HTTP or WebSocket,
and translates this into the proper function call on the server.

The client is responsible for structuring requests into RPC that the server can understand. When you make a function
call using the client, that function call is translated into RPC using a recursive JavaScript Proxy. The Proxy object is
JavaScript's answer to meta-programming and allows tools like Prim+RPC to inspect usage of properties and methods on an
object. This means that Prim+RPC doesn't need to generate a client to communicate with the server. Instead, it uses the
language itself.

There are many other more intricate details concerning how Prim+RPC works: batching requests, handling files,
interaction with plugins, just to name a few. These are topics that may be covered in-depth as this documentation
progresses.

## Next Steps

Yes! This introduction has only shown the basic RPC features available with Prim+RPC. There are many additional features
like callback support and file upload handling, options that you can configure, plugins that you can utilize (or create
your own), serialization handlers for RPC that you can customize, documentation that you can generate, and more. See the
Table of Contents for some guides that I've built as a reference.

I personally work with many different frameworks and created Prim+RPC to make working with various frontends and
backends easier by making an RPC framework that is highly modular and can work with any frontend or backend. It is also
a necessary stepping block for me to build Prim+CMS, for which I'll be announcing more details in the future. I chose to
make this project open source for several reasons but primarily because many of the tools that I use today are also open
source. The availability of these tools are a big part of why I am a developer today and that ecosystem is something
that for which I hope I can contribute back. I hope that you find this library useful and that it helps other developers
like yourself whether you are experienced or just starting out.

If you do find this tool useful, consider giving it a star on Github, contributing back to the project (whether to the
core project or a plugin for it), sponsoring the project, or by working with Ted through his company, Dose of Ted.
