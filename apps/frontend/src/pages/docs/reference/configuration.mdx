{/* SECTION: setup */}

import { LayoutDocs } from "@/components/LayoutDocs"
import { Alert } from "@/components/Alert"
export const meta = {
	title: "Configuration Reference",
}
export default ({ children }) => <LayoutDocs meta={meta}>{children}</LayoutDocs>

{/* !SECTION setup */}

# {meta.title}

<Alert icon="carbon:warning" type="alert-warning">
	Work in Progress
</Alert>

Prim+RPC includes two functions for configuring Prim+RPC: one for the client (`createPrimClient()`) and another for the
server (`createPrimServer()`). Both of these functions accept options and are given in this reference guide.

This guide is split up into two sections: client options and server options. The Prim+RPC client expects client options
only while the Prim+RPC server accepts both client and server options.

The Prim+RPC server shares options with the client for two reasons. The first: some options should be shared with both
the server and client. For instance, if the JSON handler is changed on the client then it should also be changed on the
server for proper serialization. The second: if a function doesn't exist on module provided to Prim+RPC server then the
Prim+RPC server will create a new Prim+RPC client to contact another server (this is totally optional and allows
communication between multiple servers with dedicated responsibilities).

<Alert icon="carbon:information" type="alert-info" prose>

Some options must be set to the same value on both the server and the client. To make clear which properties must be
synced between client/server, you'll find a **Sync Requirement** for each option below that will be either: **游릭 No**
meaning that the option can differ, or **游댮 Yes** meaning that option must be the same.

</Alert>

## Table of Contents

## Client

The following options are available to the `createPrimClient`:

```typescript
// Tap option name below to see documentation
// You do not need to provide all of these options. This is just a demonstration.
createPrimClient({
	// link[2:9] #endpoint
	endpoint: "/prim",
	clientBatchTime: 15,
	jsonHandler: JSON,
	methodPlugin: createMethodPlugin(),
	callbackPlugin: createCallbackPlugin(),
})
```

### `.jsonHandler`

| Required  | Default  | Sync Requirement |
| --------- | -------- | ---------------- |
| _`false`_ | _`JSON`_ | 游댮 Yes           |

Functions used with Prim+RPC have to be serialized before sending a function call (RPC) to the server. By default, any
RPC made with Prim+RPC will use the environment's default JSON handler.

This can be overridden by providing your own JSON handler. The given handler must follow the same/similar signature of
the default JSON handler: namely, it needs to have `.parse()` and `.stringify()` methods.

```typescript
import superjson from "superjson"

createPrimClient({
	// superjson has both a stringify and parse method that can be used by Prim+RPC.
	jsonHandler: superjson,
})
```

This can be useful for parsing additional types. For example, [`superjson`](https://www.npmjs.com/package/superjson) is
great for parsing additional JavaScript types, [`devalue`](https://www.npmjs.com/package/devalue) is useful for cyclical
references, [`destr`](https://www.npmjs.com/package/destr) for someone security-minded. You could even use
[`yaml`](https://www.npmjs.com/package/yaml) if readability is top priority. These are only examples and you can use any
JSON handler or create your own.

<Alert icon="carbon:warning" type="alert-warning" prose>

At this stage of the project, the JSON handler must serialize data into a string. Binary data support for the JSON
handler is planned for the future to support other potential JSON-like handlers like
[`@msgpack/msgpack`](https://www.npmjs.com/package/@msgpack/msgpack). Of course, you can still upload files using
Prim+RPC because, by default, files are extracted from the RPC and sent separately.

</Alert>

It is important to note that this option must be set to the same option on both the server and client since
serialization on the client and deserialization on the server go hand-in-hand.

<Alert icon="carbon:information" type="alert-info" prose>

Some clients may not be able to support a custom JSON handler (for instance, native apps that don't use JavaScript). In
these instances, you may consider creating two Prim+RPC servers that use the same module: one that uses the default JSON
handler, and the second that uses your custom JSON handler (for clients that _can_ support it).

</Alert>

### `.handleError`

| Required  | Default  | Sync Requirement |
| --------- | -------- | ---------------- |
| _`false`_ | _`true`_ | 游댮 Yes           |

By default in JavaScript, the `Error` instance used in JavaScript does not make useful properties like `.message`
enumerable which means that when you try to stringify an `Error` with `JSON` you do not get back these properties.
Instead, you get an empty object.

To make for an easier development experience, Prim+RPC will serialize thrown errors to be sent back to the client using
[serialize-error](https://www.npmjs.com/package/serialize-error), when using the default JSON handler. This means that
if you throw an error from a function on a Prim+RPC server, the Prim+RPC client will receive that same error message. By
default, this option is set to `true`.

If the default JSON handler is changed, for instance if you use [superjson](https://github.com/blitz-js/superjson) which
already serializes errors, then this option is set to `false` so as not to conflict with possible error handling done in
the custom JSON handler.

Importantly, if you explicitly specify the `.handleError` property then your choice will be respected regardless of what
JSON handler you are using. The default conditions of setting `handleError` only apply when the option is not provided
by the developer.

This option must be set to the same value on the server and client.

### `.endpoint`

| Required  | Default     | Sync Requirement |
| --------- | ----------- | ---------------- |
| _`false`_ | _`"/prim"`_ | 游릭 No            |

It is very common to use Prim+RPC with a web server so the `endpoint` option is a URL provided directly on the Prim+RPC
client. This option is passed to both the [`methodHandler`](#method-handler) and the
[`callbackHandler`](#callback-handler) functions as an argument so that they can make connections.

This option can be overridden for the [`callbackHandler`](#callback-handler) by providing the
[`wsEndpoint`](#wsendpoint) option.

<CH.Spotlight>

```typescript
createPrimClient({
	// Provide the path if the Prim+RPC client/server are on the same domain
	endpoint: "/prim",
})
```

---

Path

---

```typescript
createPrimClient({
	// You don't have to provide endpoint if not utilized (for instance when using IPC)
	endpoint: null,
})
```

None

---

```typescript
createPrimClient({
	// Provide a full URL if Prim+RPC server is on separate domain
	// (tip: make sure proper CORS rules are enabled on server)
	endpoint: "https://api.example.com/prim",
})
```

Full URL

---

```typescript
createPrimClient({
	// Pass a different URL depending if rendered on client/server (SSR)
	endpoint: typeof window === "undefined" ? "http://localhost:1234" : "https://api.example.com/prim",
})
```

Conditional URL

</CH.Spotlight>

### `.wsEndpoint`

| Required  | Default | Sync Requirement |
| --------- | ------- | ---------------- |
| _`false`_ | _`""`_  | 游릭 No            |

The [`callbackHandler`](#callback-handler) may use a different URL from the [`methodHandler`](#method-handler). In these
events, `wsEndpoint` can be provided. This is common when the method handler uses the HTTPS protocol while the callback
handler uses the WebSocket protocol.

### `.clientBatchTime`

| Required  | Default | Sync Requirement |
| --------- | ------- | ---------------- |
| _`false`_ | _`0`_   | 游릭 No            |

The Prim+RPC client can batch RPCs made with its method handler. This is useful when using Prim+RPC with an HTTP server
and you want to avoid sending hundreds of HTTP requests.

By default, Prim+RPC does not batch requests: the batch time is set to zero. If non-zero then Prim+RPC will wait a short
time, in milliseconds, before sending HTTP requests. Of course, if one function call depends on another then that will
not be batched (because you need the result of the first to make the second call).

As a recommendation, keep this time very low (under `15`ms). The default is `0` (don't batch).

<Alert icon="carbon:information" prose>

This does not apply to the callback handler which will send RPCs one-by-one regardless of this setting. The reason for
this that the method handler is used to send a single request and receive a single response, usually over HTTP, which
results in additional overhead. The callback handler however will typically keep an open connection so there is less
overhead in sending requests, usually over WebSocket, where batching requests isn't as useful.

</Alert>

## Server

### `.module`

| Required  | Default       | Sync Requirement |
| --------- | ------------- | ---------------- |
| _`false`_ | _`undefined`_ | 游릭 No            |

When an RPC is received by the Prim+RPC server, it will be translated into a function call to be made on the provided
JavaScript module. If a module is not provided then Prim+RPC will return an error.

However, if a module is not provided but a method plugin or callback plugin are given, then the Prim+RPC server will
forward that request using the provided plugins (potentially to a separate Prim+RPC instance that does have the module).

<CH.Spotlight>

```typescript
import * as module from "./my-local-module"

createPrimServer({
	module,
})
```

---

Local Module

---

```typescript
function helloWorld() {
	return "Hello!"
}
helloWorld.rpc = true

createPrimServer({
	module: { helloWorld },
})
```

Inline Module

---

```typescript
import { upperFirst } from "lodash"

createPrimServer({
	module: { upperFirst },
	allowList: { upperFirst: true },
})
```

External Module

</CH.Spotlight>

<Alert icon="carbon:information" prose>

All functions need to be explicitly allowed before being used with Prim+RPC. This is typically done by adding a `.rpc`
property to each function. When using an external module you may not be able to add a property to an existing function.
In these cases you can use the [`allowList`](#allowlist) option of Prim+RPC to specify that a module is allowed to be
used.

</Alert>

### `.allowList`

| Required  | Default | Sync Requirement |
| --------- | ------- | ---------------- |
| _`false`_ | _`{}`_  | 游릭 No            |

All functions provided to Prim+RPC must explicitly be marked usable as RPC. This is typically done by adding a `.rpc`
property to the function in question. Sometimes this is not possible, such as when using a separate package directly
with Prim+RPC that does not have an RPC property. In these events, you may specify an allowed list of functions that can
be used.

When Prim+RPC receives an RPC it will check the `.rpc` property and, if not found, follow the allow-list. The allow list
is expected to follow the same structure as the module you provide. The allow list below is a simple example and follows
the same structure of the module provided:

```typescript
// it's easier to specify the `.rpc` property on functions but below is also completely valid
createPrimServer({
	module: {
		hi() {
			return "Hi!"
		},
		good: {
			bye() {
				return "Goodbye!"
			},
		},
	},
	allowList: {
		hi: true,
		good: {
			bye: true,
		},
	},
})
```

### `.methodsOnMethods`

| Required  | Default | Sync Requirement |
| --------- | ------- | ---------------- |
| _`false`_ | _`[]`_  | 游릭 No            |

By default, Prim+RPC will not answer methods calls made on a function. For instance, if you have a function named
`hello()`, you cannot call `hello.toString()`. However, there may be circumstances where you'd like to allow certain
methods on a defined function. For instance, the following could be useful:

```typescript
function sayHello() {
	return "Hello!"
}
sayHello.rpc = true
sayHello.docs = function () {
	return "I say hello!"
}
```

By default, `sayHello.docs()` is not allowed to be called. This can be fixed by specifying the following:

```typescript
import { sayHello } from "./previous-example"

createPrimServer({
	module: { sayHello },
	methodsOnMethods: ["docs"],
})
```

Now, any function that has a `.docs()` method can be called.

<Alert icon="carbon:warning" type="alert-warning" prose>

It is recommended, but not required, that you choose unique method names and avoid exposing or using the same names as
built-in methods, when using this option.

</Alert>
