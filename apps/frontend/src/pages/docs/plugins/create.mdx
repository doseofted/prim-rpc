{/* SECTION: setup */}

import { LayoutDocs } from "@/components/LayoutDocs"
import { Alert } from "@/components/Alert"
export const meta = {
	title: "Create an Integration",
}
export default ({ children }) => <LayoutDocs meta={meta}>{children}</LayoutDocs>

{/* !SECTION setup */}

# {meta.title}

Prim+RPC works over the transport of your choice through the usage of plugins. There are four types of plugins, split
into two categories: a **client plugin** that sends RPC and expect a result, and a **server handler** that receives
given RPC and returns a result.

On both the client and the server, there are two types of plugins/handlers. There are **method handlers** used to send
RPC and receive an immediate RPC result and **callback handlers** which are used to send RPC and await multiple results
over time. Each method _handler_ on the server-side works with the client through a method _plugin_. The same applies to
callbacks: each server-side handler must have a client-side plugin.

For example: if you're already using Express as an HTTP server then you may want to use Prim+RPC with the
[Express method handler](/docs/plugins/server#express) on the server. Since you're using an HTTP server, you'll also
need a client-side plugin that can send and receive HTTP requests. For this purpose, you may use the
[Fetch method plugin](/docs/plugins/client#fetch-api-browser) which uses the web browser's Fetch API to communicate with
your server.

As another example, you may want to support callbacks on your function calls used with Prim+RPC. For this, you'll need a
callback handler. If you are using "ws" (a WebSocket library for Node) then you may use the
[ws callback handler](/docs/plugins/server#ws). You'll also need a corresponding callback plugin on the client. Since
we're using a WebSocket on the server, we'll use the
[WebSocket callback plugin](/docs/plugins/client#websocket-api-browser) which uses the web browser's WebSocket API to
communicate with your server. You may use the method and callback plugins at the same time with Prim+RPC because it will
know when to use one versus the other.

Now that we understand the responsibilities of each plugin/handler, we can determine what type of plugin that we'd like
to create and learn how to create it next.

## Table of Contents

## Method Plugin

The method plugin is given options from the Prim+RPC client and is called whenever it needs to communicate with the
Prim+RPC server. Every method plugin starts with the following skeleton:

```typescript
import type { PrimClientMethodPlugin } from "@doseofted/prim-rpc"

interface Options {
	/* (options for your plugin) */
}
export function createMethodPlugin(options?: Options): PrimClientMethodPlugin {
	return async (endpoint, jsonBody, jsonHandler, blobs) => {
		// ... plugin code here
	}
}

// this method plugin can be passed to Prim+RPC
const methodPlugin = createMethodPlugin()
```

The `createMethodPlugin` function returns a function that is registered with Prim+RPC. Whenever Prim+RPC calls this
function, it will populate the parameters of your function. The `endpoint` is a URL configured on the Prim+RPC client's
`.endpoint` option (only needed if your plugin communicates over a URL). The `jsonBody` parameter is either a single RPC
call or, if batching is enabled, a list of RPC calls. This is given as a regular JavaScript object. Most transports
can't send this object without serialization so the next parameter, `jsonHandler`, is a JSON handler that has an
interface resembling `JSON` (the JSON handler may be overridden in the client but is expected to follow the same
interface). The last parameter is `blobs` and is only used if your JSON handler does not support file uploads (most will
not). This is a key/value record where the key is a string identifier used in the RPC (in `jsonBody`) and the value is
the binary file. Since most JSON-like handlers can't support binary objects, it is expected to handle this parameter
separately in your communication channel from the RPC (for example, use FormData to send both the RPC and binary blobs).

You may browse the source code of available method plugins to see full examples but we'll demonstrate a simple example
like so:

```typescript
import type { PrimClientMethodPlugin } from "@doseofted/prim-rpc"

interface Options {
	headers?: Record<string, string>
}
export function createMethodPlugin(options?: Options): PrimClientMethodPlugin {
	const { headers = {} } = options ?? {}
	return async (endpoint, jsonBody, jsonHandler, blobs) => {
		const result = await fetch(endpoint, {
			method: "POST",
			headers: { "content-type": jsonHandler.mediaType, ...headers },
			body: jsonHandler.stringify(jsonBody),
		})
		return jsonHandler.parse(await result.text())
	}
}

// this method plugin can be passed to Prim+RPC
const methodPlugin = createMethodPlugin({
	headers: {
		"x-my-example-header": "hello",
	},
})
```

Of course, this example is intended to be simple. It doesn't have additional handling of errors or support for the blobs
parameter. However, this does demonstrate how you can send off RPC requests to a server.

This example shows how to send off an RPC request. In the next example, we'll look at how to create a method handler
that can read this request in Prim+RPC.

## Method Handler

The method handler plugin is given methods from the Prim+RPC server and is called whenever a request comes in from your
configured server. Despite being called the Prim+RPC "server", Prim+RPC does not include a server in itself. Instead,
requests are given to the server of your choice (for instance, an HTTP framework like Express) and then that server
forwards the request to Prim+RPC. These requests are handled by Prim+RPC with either a method or callback "handler"
plugin. Every method handler starts with a skeleton like so:

```typescript
import type { PrimServerMethodHandler } from "@doseofted/prim-rpc"

interface Options {
	/* (options for your handler plugin) */
}
export function createMethodHandler(options: Options): PrimServerMethodHandler {
	return prim => {
		// ... handler registration here
	}
}
```

The `createMethodHandler` function configures the server with the options you pass to it. Generally, you pass this
function an instance of your server. In the function returned (with `prim` parameter), you set up Prim+RPC with your
server framework. In server frameworks like Express this would be considered middleware (in Fastify, a plugin). Below is
an example that configures a generic Connect middleware (popular with frameworks like Express) as a method handler in
Prim+RPC:

```typescript
import type { PrimServerMethodHandler } from "@doseofted/prim-rpc"
import type { Application } from "express"

interface Options {
	app: Application
}
export function createMethodHandler(options: Options): PrimServerMethodHandler {
	return prim => {
		app.use((req, res, next) => {
			const server = prim.server()
			if (req.path.startsWith(prim.options.prefix)) {
				server
					.call({
						url: req.url,
						body: req.body,
						method: req.method,
					})
					.then(result => {
						res.status(result.status).set(result.headers).send(result.body)
					})
			} else {
				next()
			}
		})
	}
}
```

The `prim` parameter given on the method handler is populated by Prim+RPC and includes methods to call a function based
on RPC given to your server framework. For every request, you call `prim.server()` to create a new instance of the
Prim+RPC server. This returns several methods that can be used in a request. For most HTTP server frameworks, you can
use `server.call()` to pass common HTTP-specific parameters and get back common HTTP response options. Alternatively,
you may call `server.prepareCall()`, `server.prepareRpc()`, then `server.prepareSend()` successively (this is what
`server.call()` is actually doing). If you're not using an HTTP server, then you may want to use just
`server.prepareRpc()` to pass RPC directly to Prim+RPC and receive the result back.

Like the method plugin example prior, this is a simplified example and doesn't consider conditions such as usage of
other middleware, errors, blobs or otherwise. You may refer to existing built plugins to see how they are built to learn
more.

## Callback Plugin

<Alert icon="carbon:warning" type="alert-warning">
	Documentation in Progress
</Alert>

## Callback Handler

<Alert icon="carbon:warning" type="alert-warning">
	Documentation in Progress
</Alert>
