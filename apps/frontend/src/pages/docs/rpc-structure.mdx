{/* SECTION: setup */}

import { LayoutDocs } from "@/components/LayoutDocs"
import { Alert } from "@/components/Alert"
export const meta = {
	title: "RPC Structure",
}
export default ({ children }) => <LayoutDocs meta={meta}>{children}</LayoutDocs>

{/* !SECTION setup */}

# {meta.title}

<Alert icon="carbon:information" type="alert-info">

This is a slightly more advanced guide for those using Prim+RPC outside of JavaScript. **You do not need to read this to
understand how to use Prim+RPC.**

</Alert>

While using Prim+RPC's client to generate RPC is incredibly easy and painless, there may be situations where you would
like to learn how to structure a request to a Prim+RPC server. Maybe you are developing an application with Swift/Kotlin
and need to connect to Prim+RPC from an ordinary HTTP client, maybe you're looking to intercept requests with a Web
Worker for caching, or maybe you are just curious as to how it works.

Before you learn how to format an RPC manually, you should also know that Prim+RPC has a low-level documentation
generator for which you could generate RPC snippets for popular HTTP clients using
[HTTPSnippet](https://github.com/Kong/httpsnippet). These can be customized for your own code being used with Prim+RPC.
This is useful when you have potentially hundreds of different method calls to make. Otherwise, you may just learn how
to make the request yourself since it is designed to be easy to do.

While Prim+RPC only deals with the RPC portion of the request, plugins used with Prim+RPC generally follow a particular
format to deliver that RPC (although they're not technically required to do so). We'll discuss this by working with
typical RPCs that may be sent in Prim+RPC.

## Table of Contents

## Simple RPC

Let's look at a simple function call and compare it directly against the resulting RPC. We'll define the client and
server in the same file for easier reading. In a real-world scenario, we would use a Prim+RPC plugin but we'll use
testing plugins for example.

```ts index.ts mark=2:5,16:17
import { createPrimClient, createPrimServer, testing } from "@doseofted/prim-rpc"
// define the function
function add(a: number, b: number) {
	return a + b
}
// assign property "rpc" (otherwise the function isn't allowed to be called remotely)
add.rpc = true
// we'll give Prim RPC Server a module (or a variable resembling a module, like below)
const module = { add }
// create plugins for testing Prim RPC locally (real-world usage may use HTTP/WS plugins)
const { callbackHandler, methodHandler, client, socket } = testing.createPrimTestingPlugins()
// pass module and plugins to Prim RPC server
const backend = createPrimServer({ module, methodHandler, callbackHandler })
// create a Prim RPC client (and give plugins used to communicate with server)
const frontend = createPrimClient<typeof module>({ client, socket })
// now make the function call (we can compare this to the expected result, for testing)
const result = await frontend.add(1, 2)
const expected = module.add(1, 2)
console.log(result, result === expected)
```

The function call above, when used with Prim+RPC, would generate the following RPC request and result:

<CH.Code>

```json request.json
{
	"id": "...",
	"method": "add",
	"params": [1, 2]
}
```

---

```json response.json
{
	"id": "...",
	"result": 3
}
```

</CH.Code>

It's that simple! If you were to make this RPC manually, you wouldn't even need to include the "id" property in the
request (this is optional and is used by the Prim+RPC client to sort out batched requests). Depending on how you
send/receive RPC, this result may be wrapped in some other other container, like an HTTP request, but the RPC itself is
contained in this JSON.

We simply gave the method name and arguments to the method then received a result. Our arguments were given as an array
because we have more than one but if we had a single argument (maybe an object), then we would simply need to pass that
argument, no array needed (but you could keep if you like). See the following:

<CH.Code>

```ts index.ts
/** Alternative version of example above. Notice that there's now a single parameter. */
function add(options: { a: number; b: number }) {
	return options.a + options.b
}
```

---

```json request.json
{
	"method": "add",
	"params": {
		"a": 1,
		"b": 2
	}
}
```

---

```json response.json
{
	"result": 3
}
```

</CH.Code>

## With Callback

## With Custom JSON Handler

## With File
