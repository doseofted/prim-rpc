{/* SECTION: setup */}

import { LayoutDocs } from "@/components/LayoutDocs"
import { Alert } from "@/components/Alert"
import { Tab } from "@headlessui/react"
export const meta = {
	title: "Setup",
}
export default ({ children }) => <LayoutDocs meta={meta}>{children}</LayoutDocs>

{/* !SECTION setup */}

# {meta.title}

In this guide, we'll learn how to set up an existing project to use Prim+RPC. If you don't have an existing project to
set up, you can download an example project made for this guide below. You may also reference
[the available examples](/docs/examples) on this website to act as a starting point.

Once you've finished this guide and set up your project, you can [learn how to write a function](/docs/usage) to be
shared as Prim+RPC.

## Table of Contents

## Prerequisites

It is assumed that you have some experience writing JavaScript and have seen some TypeScript in the wild (you don't need
to be an expert). It's also assumed that you have heard of popular JavaScript tools like Vite and Fastify. You don't
need to be an expert in either and neither are requirements for using Prim+RPC. They will be used to make the tutorial
easier to follow and commands/code will be given in this guide to make examples work.

## Installation

We will be setting up Prim+RPC on both the **server** and the **client**.

The server is where your JavaScript functions are located; functions that you'd like to share with someone else. The
client will call these JavaScript functions remotely. Typically the server is some HTTP or WebSocket server and the
client is a web browser or native application that makes requests to this server. In other cases, the server may be
running in one process while the client is running in a separate process on the same machine. However you're using up
Prim+RPC, this guide should apply to all relationships between client and server.

The first step to use Prim+RPC will be to add the library to both the server and client portions of your project. If
your client and server are located in separate projects, you should install the following packages in both:

- **Prim+RPC**: contains both client and server tools for making RPC; framework-agnostic
- **Prim+RPC Plugins**: framework-specific plugins for Prim+RPC, both client and server side

You may optionally install **Prim+RPC Tooling** for helpful Prim+RPC-related tools. The Tooling package is completely
optional and includes utilities like a documentation generator as well as a build plugin that prevents the import of a
function from the server directly (it's always safe to import types but the import of code from the server is usually
not intended so this plugin stops that from happening). The Tooling package is included in the install commands below.

Provided are installation commands for common package managers.

<CH.Code>

```zsh npm
npm add @doseofted/prim-rpc @doseofted/prim-rpc-plugins @doseofted/prim-rpc-tooling
```

```zsh yarn
yarn add @doseofted/prim-rpc @doseofted/prim-rpc-plugins @doseofted/prim-rpc-tooling
```

```zsh pnpm
pnpm add @doseofted/prim-rpc @doseofted/prim-rpc-plugins @doseofted/prim-rpc-tooling
```

```zsh bun
bun add @doseofted/prim-rpc @doseofted/prim-rpc-plugins @doseofted/prim-rpc-tooling
```

</CH.Code>

You may also use Prim+RPC with Deno or from a CDN:

<CH.Code>

```ts Deno
import { createPrimServer, createPrimClient } from "npm:@doseofted/prim-rpc"
// use available export in place of {PLUGIN_NAME} below
import {
	createMethodHandler,
	createCallbackHandler,
	createMethodPlugin,
	createCallbackPlugin,
} from "npm:@doseofted/prim-rpc-plugins/{PLUGIN_NAME}"
// the following import is only if you're using Prim+RPC tooling
import "npm:@doseofted/prim-rpc-tooling/{TOOL_NAME}"
```

```ts esm.sh
import { createPrimServer, createPrimClient } from "https://esm.sh/@doseofted/prim-rpc"
// use available export in place of {PLUGIN_NAME} below
import {
	createMethodHandler,
	createCallbackHandler,
	createMethodPlugin,
	createCallbackPlugin,
} from "https://esm.sh/@doseofted/prim-rpc-plugins/{PLUGIN_NAME}"
// the following import is only if you're using Prim+RPC tooling
import "https://esm.sh/@doseofted/prim-rpc-tooling/{TOOL_NAME}"
```

```ts skypack.dev
import { createPrimServer, createPrimClient } from "https://cdn.skypack.dev/@doseofted/prim-rpc"
// use available export in place of {PLUGIN_NAME} below
import {
	createMethodHandler,
	createCallbackHandler,
	createMethodPlugin,
	createCallbackPlugin,
} from "https://cdn.skypack.dev/@doseofted/prim-rpc-plugins/{PLUGIN_NAME}"
// the following import is only if you're using Prim+RPC tooling
import "https://cdn.skypack.dev/@doseofted/prim-rpc-tooling/{TOOL_NAME}"
```

```ts unpkg.com
import { createPrimServer, createPrimClient } from "https://unpkg.com/@doseofted/prim-rpc"
// use available export in place of {PLUGIN_NAME} below
import {
	createMethodHandler,
	createCallbackHandler,
	createMethodPlugin,
	createCallbackPlugin,
} from "https://unpkg.com/@doseofted/prim-rpc-plugins/{PLUGIN_NAME}"
// the following import is only if you're using Prim+RPC tooling
import "https://unpkg.com/@doseofted/prim-rpc-tooling/{TOOL_NAME}"
```

</CH.Code>

Now you're ready to start setting up the client and the server! You may either follow setup instructions below or you
can look at [one of the available examples](/docs/examples) for reference.

We'll separate client/server steps and start with the server first.

## Server Setup

The Prim+RPC server hosts your JavaScript functions and makes them available to the Prim+RPC client. You can write
regular JavaScript functions and then pass them to Prim+RPC to make them available to the server.

For this example, we'll pretend that we have an existing JavaScript file that we'd like to work with Prim+RPC. Note that
TypeScript here is optional and we use it here only as an example.

```typescript hello.ts
/**
 * This function just says hello.
 */
export function sayHello(x: string, y: string) {
	return `${x}, meet ${y}.`
}
// JavaScript functions are objects so we can add additional properties to them
// We add the `.rpc` property to explicitly say that this function can be used as RPC
sayHello.rpc = true
```

Note that we added a `.rpc` property to the function. Prim+RPC will look for this property before it is allowed to
execute the function remotely. If you can't add the the `.rpc` property (maybe the
[function is frozen](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze))
then you can also specify that it's allowed to be called by using the
[`.allowList`](/docs/reference/configuration#allowlist) option on the Prim+RPC server.

Prim+RPC works with the server of your choice through the use of handler plugins. There are two types of handlers that
you can configure with the Prim+RPC server. The **method handler** is used to resolve method calls in Prim+RPC. The
**callback handler** is optional and can be used both to resolve methods but also to resolve callbacks given on a
method. You can use both a method and callback handler with Prim+RPC at the same time or use one of them at a time (your
choice).

The reason that there are two types of handlers and why the callback plugin is optional is because, while the callback
handler is incredibly useful, not everyone needs it. Method handlers are easier to write and understand how they work
because they handle a request from the client and send back a response (a simple transaction). A callback handler on the
other hand keeps an open connection to the client so that multiple responses can be sent back (like when a callback is
called multiple times). Callback handlers are incredibly useful for real-time information (like a chat app) but can
become expensive for large applications because your server must maintain active connections to the client.

If interested, you may learn more about [how plugins/handlers work](/docs/plugins/create) in the plugin creation guide.

```typescript
// ...
```

## Client Setup

The Prim+RPC client communicates with the Prim+RPC server. You simply call your JavaScript function on the client, as if
it exists on your local machine (which it doesn't), and get a result back. The client intercepts the function call and
sends that to the Prim+RPC server. Once a response is received from the server, the client receives this result and
hands it back to the function that you called.

This is done using a
[JavaScript Proxy object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy). The
function that you call on the client doesn't actually exist but rather the function name and arguments are given to the
Prim+RPC client so that it can send those to the server where your function is actually located.

The Prim+RPC client communicates with your server through the use of plugins. The Prim+RPC client itself turns your
function call into RPC and sends that RPC to plugins. There are two types of plugins that you can provide to the
Prim+RPC client.

The **method plugin** receives RPC from the client, sends it to the server, receives a result from the server, and gives
the result back to the Prim+RPC client. The method **plugin** communicates with the method **handler** defined on the
Prim+RPC server.

The **callback plugin** is optional and keeps an open connection to the server. It receives RPC from the client when a
callback is given, sends it to the server, and awaits multiple results from the server. As these results are received,
they are given back to the Prim+RPC client. The callback **plugin** communicates with the callback **handler** defined
on the Prim+RPC server.

It is important to use a compatible plugin and handler (for both methods and callbacks). For instance, if you use a
plugin that sends HTTP requests then you need a handler that can receive HTTP requests. As another example, if you use a
plugin for Web Workers then you need a handler for Web Workers.

...
