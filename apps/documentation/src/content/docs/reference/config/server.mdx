---
title: Server Configuration
---

import CodeFile from "@/components/Code/CodeFile.astro"
import Aside from "@/components/Markdown/Aside.astro"
import ServerNotice from "@/components/Snippets/ServerNotice.astro"
import CodeTabs from "@/components/Code/CodeTabs.react.tsx"
import Code from "@/components/Code/Code.astro"
import { Icon } from "astro-icon/components"
import Button from "@/components/Markdown/Button.astro"
import ButtonGroup from "@/components/Markdown/ButtonGroup.astro"

<a href="/docs/reference/config" class="-mx-3 my-2 mb-4 btn btn-sm btn-ghost no-underline">
	<Icon name="ph:caret-left-bold" />
	<span>Configuration</span>
</a>

# {frontmatter.title}

These are options specific to the server. Options that work on both the server and the client are documented in the
[shared configuration](/docs/reference/config/shared).

<ButtonGroup>
	<Button href="/docs/reference/config/shared" icon="ph:wrench-bold">
		Shared Configuration
	</Button>
</ButtonGroup>

## <Icon name="ph:brackets-curly-bold"/> Allow List

<CodeFile>

```typescript
const module = {
	default: () => "Hi!",
	good: { morning: () => "Good morning!" },
}
const allowList = {
	default: true,
	good: { morning: true },
}
createPrimServer({ module, allowList })
```

</CodeFile>

By default, functions given to Prim+RPC are not allowed to be called unless a `.rpc` property is set on the function or
that function is added to an allow list.

The Allow List is an object that resembles the module that you give to Prim+RPC where each function name is a key and
the value is a boolean flag stating whether that function should be considered RPC.

## <Icon name="ph:brackets-curly-bold"/> Methods on Methods

<CodeFile>

```typescript
function hello() {
	return "Hello from Prim+RPC!"
}
hello.rpc = true
hello.documentation = () => "I say hello"

createPrimServer({
	module: { hello },
	methodsOnMethods: ["documentation"],
})
```

</CodeFile>

By default, functions are not allowed to be called with Prim+RPC if, anywhere in the chain, it is defined on another
function. The exception to this rule is if a method is defined directly on another method _and_ the name of that method
is given in this option. This may be useful for adding metadata to your functions.

## <Icon name="ph:brackets-curly-bold"/> Show Error Stack

<CodeFile>

```typescript
createPrimServer({
	handleError: true,
	showErrorStack: process.env.NODE_ENV === "development",
})
```

</CodeFile>

When the [Handle Error](#-handle-error) option is set to true, Prim+RPC will send the error message to the client. On
the server this could potentially include a stack trace. By default, Prim+RPC will not send the stack trace to the
client. This option can be set to true to override this behavior. This is useful in development but depending on your
security needs may not be wanted in production.

## <Icon name="ph:brackets-curly-bold"/> Prefix

<CodeFile>

```typescript
const prefix = "/prim"
createPrimServer({ prefix })
```

</CodeFile>

The Prefix option is a convenience option to be used by plugins that communicate over a specific address, specifically
HTTP and WebSocket servers. It can be used by plugins to establish a path of a URL. By default, it is set to
`/prim{:txt}` so as not to collide with other possible routes on an existing server. If Prim+RPC is the only service
used with a server, you may change this to `/{:txt}` (or any other path that you'd like).

## <Icon name="ph:brackets-curly-bold"/> Method Handler

<CodeFile>

```typescript
import { createMethodHandler } from "@doseofted/prim-rpc-plugins/hono"
import { Hono } from "hono"

const app = new Hono()
const methodHandler = createMethodHandler({ app })
createPrimServer({ methodHandler })
```

</CodeFile>

The Method Handler takes a request from the server and extracts RPC from it before sending it to the Prim+RPC server. It
also formats the RPC back into a response for your chosen server. Each method handler on the server has a corresponding
[Method Plugin](#-method-plugin) on the client that can understand communicate with it.

There are handlers already available to use but you may also create your own.

<ButtonGroup>
	<Button href="/docs/reference/plugins#server-handlers" icon="ph:code-block-bold">
		Method Handlers
	</Button>
	<Button href="/docs/reference/create#method-handler" icon="ph:lightbulb-bold">
		Create a Method Handler
	</Button>
</ButtonGroup>

## <Icon name="ph:brackets-curly-bold"/> Callback Handler

<CodeFile>

```typescript
import { createCallbackHandler } from "@doseofted/prim-rpc-plugins/ws"
import { WebSocketServer } from "ws"

const wss = new WebSocketServer({ port: 1234 })
const callbackHandler = createCallbackHandler({ wss })
createPrimServer({ callbackHandler })
```

</CodeFile>

The Callback Handler is similar to the [Method Handler](#-method-handler) but is primarily intended to handle callbacks
given on functions. The primary difference between the two is that the Method Handler sends a response for every request
while the Callback Handler may send multiple responses for a request (because callbacks may be fired multiple times).

It can be used alone or alongside a Method Handler, Prim+RPC is able to determine which plugin to use. Each Callback
Handler on the server has a corresponding [Callback Plugin](#-callback-plugin) on the client.

There are handlers already available to use but you may also create your own.

<ButtonGroup>
	<Button href="/docs/reference/plugins#server-handlers" icon="ph:code-block-bold">
		Callback Handlers
	</Button>
	<Button href="/docs/reference/create#callback-handler" icon="ph:lightbulb-bold">
		Create a Callback Handler
	</Button>
</ButtonGroup>

## <Icon name="ph:brackets-curly-bold"/> Pre-Call Hook

<CodeFile>

```typescript
import { parse } from "valibot"

const prim = createPrimServer({
	preCall(args, func) {
		if ("params" in func) return parse(func.params, args)
		throw new Error("Argument validation is required")
	},
})
```

</CodeFile>

The pre-call hook is optional and is executed _before_ calling a given function. It is given the arguments passed to the
server and the function that is being called. **Do not call the function inside of the hook** as Prim+RPC will call this
function itself (resulting in the function being called twice). This may be useful for logging, validation, or adding
and processing metadata attached to a function.

## <Icon name="ph:brackets-curly-bold"/> Post-Call Hook

<CodeFile>

```typescript
import { parse } from "valibot"

const prim = createPrimServer({
	postCall(returns, func) {
		if ("returns" in func) return parse(func.returns, returns)
		throw new Error("Result validation is required")
	},
})
```

</CodeFile>

The post-call hook is optional and is executed _after_ calling a given function. It is given the return value of the
function given to the server and the function that was called. **Do not call the function inside of the hook** as it
will be executed a second time.
